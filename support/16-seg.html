<html>
  <head>
    <title>16-Segments LCD Display Utility</title>
    <style type="text/css">
      #container {
        position: relative;
      }
      #canvas {
        margin-top:20px;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="value-container">Value is: <span id="value">0x0000</span></div>
      <canvas id="canvas" width="500" height="500">This text is displayed if your browser does not support HTML5 Canvas.</canvas>
    </div>
    <script type="text/javascript">
    
function Box() {
    this.x = 0;
    this.y = 0;
    this.w = 0;
    this.h = 0;
    this.fill = '#dddddd';
    this.angle = 0;
    this.selected = true;
    this.value = 0;
}

//Initialize a new Box, add it, and invalidate the canvas
function addRect(x, y, w, h, value, angle) {
    var rect = new Box;
    rect.x = (x / scale) + xOffset;
    rect.y = (y / scale) + yOffset;
    rect.w = w / scale;
    rect.h = h / scale;
    rect.angle = typeof angle !== 'undefined' ? angle : 0;
    rect.value = value;
    rect.selected = false;
    boxes.push(rect);
    invalidate();
}

var boxes = [];
var canvas;
var ctx;
var WIDTH;
var HEIGHT;
var INTERVAL = 20; // how often, in milliseconds, we check to see if a redraw is needed
var scale = 1;
var xOffset = 80;
var yOffset = 30;

var isDrag = false;
var mx, my; // mouse coordinates

// when set to true, the canvas will redraw everything
// invalidate() just sets this to false right now
// we want to call invalidate() whenever we make a change
var canvasValid = false;

// we use a fake canvas to draw individual shapes for selection testing
var ghostcanvas;
var gctx; // fake canvas context

// since we can drag from anywhere in a node
// instead of just its x/y corner, we need to save
// the offset of the mouse when we start dragging.
var offsetx, offsety;

// Padding and border style widths for mouse offsets
var stylePaddingLeft, stylePaddingTop, styleBorderLeft, styleBorderTop;

// initialize our canvas, add a ghost canvas, set draw loop
// then add everything we want to intially exist on the canvas
function init() {
    canvas = document.getElementById('canvas');
    HEIGHT = canvas.height;
    WIDTH = canvas.width;
    ctx = canvas.getContext('2d');
    ghostcanvas = document.createElement('canvas');
    ghostcanvas.height = HEIGHT;
    ghostcanvas.width = WIDTH;
    gctx = ghostcanvas.getContext('2d');

    //fixes a problem where double clicking causes text to get selected on the canvas
    canvas.onselectstart = function () {
        return false;
    }

    // fixes mouse co-ordinate problems when there's a border or padding
    // see getMouse for more detail
    if (document.defaultView && document.defaultView.getComputedStyle) {
        stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingLeft'], 10) || 0;
        stylePaddingTop = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingTop'], 10) || 0;
        styleBorderLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderLeftWidth'], 10) || 0;
        styleBorderTop = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderTopWidth'], 10) || 0;
    }

    // make draw() fire every INTERVAL milliseconds
    setInterval(draw, INTERVAL);

    // set our events. Up and down are for dragging,
    // double click is for making new boxes
    canvas.onmousedown = myDown;
    canvas.onmouseup = myUp;

    var i = 0;

    addRect(40, 20, 100, 20, 1 << (i++));
    addRect(160, 20, 100, 20, 1 << (i++));
    addRect(260, 40, 20, 160, 1 << (i++));
    addRect(260, 220, 20, 160, 1 << (i++));
    addRect(160, 380, 100, 20, 1 << (i++));
    addRect(40, 380, 100, 20, 1 << (i++));
    addRect(20, 220, 20, 160, 1 << (i++));
    addRect(20, 40, 20, 160, 1 << (i++));

    addRect(80, 50, 20, 140, 1 << (i++), -30);
    addRect(140, 40, 20, 160, 1 << (i++));
    addRect(200, 50, 20, 140, 1 << (i++), 30);
    addRect(40, 200, 100, 20, 1 << (i++));
    addRect(160, 200, 100, 20, 1 << (i++));
    addRect(80, 230, 20, 140, 1 << (i++), 30);
    addRect(140, 220, 20, 160, 1 << (i++));
    addRect(200, 230, 20, 140, 1 << (i++), -30);
}

//wipes the canvas context
function clear(c) {
    c.clearRect(0, 0, WIDTH, HEIGHT);
}

// While draw is called as often as the INTERVAL variable demands,
// It only ever does something if the canvas gets invalidated by our code
function draw() {
    if (canvasValid == false) {
        clear(ctx);

        // Add stuff you want drawn in the background all the time here

        // draw all boxes
        var l = boxes.length;
        for (var i = 0; i < l; i++) {
            drawshape(ctx, boxes[i], boxes[i].fill);
        }

        canvasValid = true;
    }
}

// Draws a single shape to a single context
// draw() will call this with the normal canvas
// myDown will call this with the ghost canvas
function drawshape(context, shape, fill) {
    context.save();
    if (shape.selected) {
        context.fillStyle = "#ff0000";
    } else {
        context.fillStyle = fill;
    }

    var cx = shape.x + (shape.w * 0.5);
    var cy = shape.y + (shape.h * 0.5);
    context.translate(cx, cy);
    context.rotate(shape.angle * Math.PI / 180);
    context.translate(-cx, -cy);
    context.fillRect(shape.x, shape.y, shape.w, shape.h);
    context.restore();

    context.save();
    if (shape.selected) {
        context.fillStyle = "#ff0000";
    } else {
        context.fillStyle = "#ffffff";
    }
    var x = shape.x / 10;
    var y = shape.y / 10;
    var w = shape.w / 10;
    var h = shape.h / 10;
    cx = x + (w * 0.5);
    cy = y + (h * 0.5);
    context.translate(cx, cy);
    context.rotate(shape.angle * Math.PI / 180);
    context.translate(-cx, -cy);
    context.fillRect(x, y, w, h);
    context.restore();
}

// Happens when the mouse is moving inside the canvas
function myMove(e) {
    return;
    if (isDrag) {
        getMouse(e);

        mySel.x = mx - offsetx;
        mySel.y = my - offsety;

        // something is changing position so we better invalidate the canvas!
        invalidate();
    }
}

// Happens when the mouse is clicked in the canvas
function myDown(e) {
    getMouse(e);
    clear(gctx);
    var l = boxes.length;
    for (var i = l - 1; i >= 0; i--) {
        // draw shape onto ghost context
        drawshape(gctx, boxes[i], 'black');

        // get image data at the mouse x,y pixel
        var imageData = gctx.getImageData(mx, my, 1, 1);
        var index = (mx + my * imageData.width) * 4;

        // if the mouse pixel exists, select and break
        if (imageData.data[3] > 0) {
            mySel = boxes[i];
            if (mySel.selected) {
                mySel.selected = false;
            } else {
                mySel.selected = true;
            }

            getValue();
            offsetx = mx - mySel.x;
            offsety = my - mySel.y;
            mySel.x = mx - offsetx;
            mySel.y = my - offsety;
            invalidate();
            clear(gctx);
            return;
        }

    }
    // havent returned means we have selected nothing
    mySel = null;
    // clear the ghost canvas for next time
    clear(gctx);
    // invalidate because we might need the selection border to disappear
    invalidate();
}

function getValue() {
    var l = boxes.length;
    var value = 0;
    for (var i = l - 1; i >= 0; i--) {
        if (boxes[i].selected) {
            value += boxes[i].value;
        }
    }
    document.getElementById("value").innerHTML = "0x" + pad(value.toString(16), 4);
}

function myUp() {
    isDrag = false;
    canvas.onmousemove = null;
}

function invalidate() {
    canvasValid = false;
}

function getMouse(e) {
    var element = canvas,
        offsetX = 0,
        offsetY = 0;

    if (element.offsetParent) {
        do {
            offsetX += element.offsetLeft;
            offsetY += element.offsetTop;
        } while ((element = element.offsetParent));
    }

    // Add padding and border style widths to offset
    offsetX += stylePaddingLeft;
    offsetY += stylePaddingTop;

    offsetX += styleBorderLeft;
    offsetY += styleBorderTop;

    mx = e.pageX - offsetX;
    my = e.pageY - offsetY
}

function pad(str, max) {
    str = str.toString();
    return str.length < max ? pad("0" + str, max) : str;
}

init();

    </script>
  </body>
</html>